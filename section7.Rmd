---
title: "section7"
output: html_document
date: "2022-12-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 分散分析
- 3つ以上の郡の平均値を比較するための手法が分散分析

## 一元配置分散分析 (対応なし)
- 例えば指導法がA~Dがあり、それぞれの指導を受けるすべての人を母集団としたときに、それぞれの指導法ごとにテストの平均得点が違いがあるかみたい
- こういうケースで分散分析を使って無造作標本から、母集団の平均を検定する
- 分散分析という名前だが、t検定とかとやろうとしてることはだいたい同じ (対応している郡の数の違い)

```{r}
A <- c(15, 9, 18, 14, 18)
B <- c(13, 8, 8, 12, 7)
C <- c(10, 6, 11, 7, 12)
D <- c(10, 7, 3, 5, 7)
stat_test_2 <- c(A, B, C, D)
stat_test_2

# 指導法ごとにカテゴリを表せるようにしておく
method <- c(rep("A", 5), rep("B", 5), rep("C", 5), rep("D", 5))
method
# 文字列型を要因型を要因型に変換する。分散分析の関数が要因型を受けるようになってる。
method_factor <- factor(method)
method_factor

# 分散分析1
# 第一引数は 従属変数~説明変数 という書式
oneway.test(stat_test_2 ~ method_factor, var.equal = TRUE)

# 分散分析2
summary(aov(stat_test_2 ~ method_factor))

# 分散分析3
anova(lm(stat_test_2 ~ method_factor))
```

- 帰無仮説: 4郡の母平均は等しい
- 対立仮設: 4郡の母平均は等しくない
- どの分散分析の関数で出力しても、検定統計量Fの実現値に対応するp値がでるので、帰無仮説を棄却するか判断できる
- 今回の検定の場合、p値が5%より小さいので、4つの指導法の間に優位な平均差が見られたといえる

### 平方和の分解
- 検定統計量Fの計算に出てくる群間平方和や群内平方和とはなんなのか？
- 群間平方和
  - 各郡の平均と全平均の差について事情和を求めたもの
  - 郡の平均値のばらつきが大きくなればなるほど、値が大きくなる。
  - つまり群の違いによって生じるばらつきを表す
- 群内平方和
  - 同じ分の中でのばらつきの大きさ
- 全体平方和
  - 群間平方和と郡内平方和を足しわせたもの
  - 全体平方和を群間平方和と郡内平方和に分けることによって、データ全体の群の違いによって説明できる部分とできない部分に分解することができる
- Fでだしたいのは概ね、群の違いでは説明できない、誤差によるばらつきなので、群間の平均平方÷群内の平均平方で求めることができる

## 二元配置分散分析 (対応なし)
- 二元配置分散分析は2つの条件の組み合わせによって、母平均が異なるかどうかを検定する
  - 一次元はある条件の違いによって母平均がことなるかを検定してる
- 主効果
  - 一元配置分析のときに考えてた効果と一緒
- 交互作用効果
  - 2つ以上の要因が組み合わされたときに生じる効果
  - グラフにプロットしていったときに全部の線が平行でないときには、交互作用効果があるといえる
- 二元配置分散分析の場合は、三種類の帰無仮説と対立仮設を建てることになる
  - 要因Aの主効果
    - 帰無仮説: 要因Aの主効果はない
    - 対立仮設: 要因Aの主効果はある
  - 要因Bの主効果
    - 帰無仮説: 要因Bの主効果はない
    - 対立仮設: 要因Bの主効果はある
  - 要因AとBの交互作用効果
    - 帰無仮説: 要因AとBの交互作用効果はない
    - 対立仮設: 要因AとBの交互作用効果はある

```{r}
taste <- c(6, 4, 5, 3, 2, 10, 8, 10, 8, 9, 11, 12, 12, 10, 10, 5, 4, 2, 2, 2, 7, 6, 5, 4, 3, 12, 8, 5, 6, 4)
taste

temperature <- factor(c(rep("冷蔵庫", 15), rep("常温", 15)))
temperature

maker <- factor(rep(c(rep("イカアン", 5), rep("ボスビック", 5), rep("ビビッテル", 5)), 2))
maker

# temperature * makerでそれぞれの趣向かと交互作用のすべてを含めるという意味になる
summary(aov(taste ~ temperature * maker))

interaction.plot(temperature, maker, taste)
interaction.plot(maker, temperature, taste)
```
